好的，這是一個很好的規劃！將匯率轉換邏輯集中管理在 functions.php 中，並將匯率的獲取和儲存獨立成另一個方法，這樣做既清晰又易於維護。

設計思路
我們將建立兩個 PHP 函數：

convertCurrency($amount, $fromCurrency, $toCurrency = 'TWD', $exchangeRate = null)：這是主要用於執行貨幣轉換的函數。它會接收要轉換的金額、來源幣別、目標幣別（預設為 TWD），以及一個可選的指定匯率。

fetchAndStoreExchangeRates($baseCurrency = 'TWD')：這個函數負責從第三方 API 獲取匯率數據並將其暫存或儲存起來，供 convertCurrency 使用。

1. convertCurrency 方法
這個方法會執行實際的貨幣轉換。

程式碼 (添加到 functions.php)

PHP

<?php
// functions.php

// 確保所有 Session 相關的 ini 設定在 session_start() 之前執行
// ... (你的現有 Session 啟動和管理邏輯，如之前討論的) ...
$session_timeout = 1800; // 設定會話過期時間為 30 分鐘（1800 秒）

ini_set('session.gc_maxlifetime', $session_timeout);
session_set_cookie_params($session_timeout);

if (session_status() == PHP_SESSION_NONE) {
    session_start();
}

include("config.php"); // 包含你的資料庫設定
include_once("parameter.php"); // 包含你的參數設定

// 統一 Session 管理邏輯
if (isset($_SESSION['last_activity']) && (time() - $_SESSION['last_activity'] > $session_timeout)) {
    session_unset();
    session_destroy();
    header('Content-Type: application/json');
    echo json_encode(['status' => 'session_expired', 'message' => '會話已過期，請重新登入。']);
    exit();
}
$_SESSION['last_activity'] = time();

// openDB 函數 (假設已在 functions.php 中定義)
// function openDB(...) { ... }

/**
 * 執行貨幣轉換。
 *
 * @param float|string $amount 要轉換的金額
 * @param string $fromCurrency 原始幣別代碼 (例如 'USD', 'JPY')
 * @param string $toCurrency 目標幣別代碼 (預設為 'TWD')
 * @param float|string|null $exchangeRate 可選：如果提供，將使用此匯率而非從資料庫獲取
 * @return float|null 轉換後的金額，如果轉換失敗則返回 null
 */
function convertCurrency($amount, $fromCurrency, $toCurrency = 'TWD', $exchangeRate = null) {
    // 確保金額是浮點數
    $amount = (float) $amount;

    // 如果原始幣別和目標幣別相同，直接返回原始金額
    if ($fromCurrency === $toCurrency) {
        return $amount;
    }

    // 如果提供了匯率，則直接使用
    if ($exchangeRate !== null) {
        $rate = (float) $exchangeRate;
        if ($rate > 0) {
            // 使用 BC Math 進行高精度計算
            return bcmul($amount, $rate, 4); // 保留4位小數
        }
        error_log("提供的手動匯率無效：{$exchangeRate}");
        return null;
    }

    // 從資料庫（或快取）獲取匯率
    // 假設你的 openDB 函數可以安全地獲取資料庫連線
    global $db_server, $db_name, $db_user, $db_passwd; // 確保這些變數在 scope 內
    try {
        $pdo = openDB($db_server, $db_name, $db_user, $db_passwd);
        $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

        // 從 exchange_rates_table 查詢匯率
        // 假設你的匯率表結構為 id, base_currency, target_currency, rate, updated_at
        // 我們通常將所有匯率都轉換為相對主要幣別的匯率（例如，以 TWD 為基準）
        // 如果你的匯率 API 是以 USD 為基準，則需要調整查詢邏輯
        // 這裡假設儲存的是 target_currency 對 base_currency 的匯率
        $stmt = $pdo->prepare("SELECT `rate` FROM `exchange_rates_table` 
                               WHERE `from_currency` = :fromCurrency AND `to_currency` = :toCurrency 
                               ORDER BY `updated_at` DESC LIMIT 1");
        $stmt->bindParam(':fromCurrency', $fromCurrency);
        $stmt->bindParam(':toCurrency', $toCurrency);
        $stmt->execute();
        $rate = $stmt->fetchColumn();

        if ($rate !== false && (float)$rate > 0) {
            // 使用 BC Math 進行高精度計算
            return bcmul($amount, (float)$rate, 4); // 保留4位小數
        } else {
            // 如果直接查詢不到 From -> To 的匯率
            error_log("在資料庫中找不到從 {$fromCurrency} 到 {$toCurrency} 的匯率。");

            // 嘗試透過主要幣別進行轉換 (例如 USD -> TWD -> JPY)
            // 這種情況需要先獲取 From -> Base 和 Base -> To 的匯率
            if ($fromCurrency !== 'TWD' && $toCurrency !== 'TWD') { // 假設 TWD 是你的預設主要幣別
                $stmtFromBase = $pdo->prepare("SELECT `rate` FROM `exchange_rates_table` 
                                               WHERE `from_currency` = :fromCurrency AND `to_currency` = 'TWD' 
                                               ORDER BY `updated_at` DESC LIMIT 1");
                $stmtFromBase->bindParam(':fromCurrency', $fromCurrency);
                $stmtFromBase->execute();
                $rateFromBase = $stmtFromBase->fetchColumn();

                $stmtToBase = $pdo->prepare("SELECT `rate` FROM `exchange_rates_table` 
                                             WHERE `from_currency` = 'TWD' AND `to_currency` = :toCurrency 
                                             ORDER BY `updated_at` DESC LIMIT 1");
                $stmtToBase->bindParam(':toCurrency', $toCurrency);
                $stmtToBase->execute();
                $rateToBase = $stmtToBase->fetchColumn();

                if ($rateFromBase !== false && (float)$rateFromBase > 0 && 
                    $rateToBase !== false && (float)$rateToBase > 0) {
                    // USD -> TWD 匯率: $rateFromBase
                    // TWD -> JPY 匯率: $rateToBase
                    // 總轉換匯率 = (1 / $rateFromBase) * $rateToBase (如果 $rateFromBase 是指 TWD/USD 則直接相乘)
                    // 這邊假設 $rateFromBase 是指 1單位 $fromCurrency 可以換多少 'TWD'
                    // $rateToBase 是指 1單位 'TWD' 可以換多少 $toCurrency
                    
                    // 嚴謹的計算方法:
                    // 1. 先把 $amount 轉換為 'TWD'
                    $amountInTWD = bcmul($amount, (float)$rateFromBase, 6); 
                    // 2. 再把 'TWD' 轉換為 $toCurrency
                    return bcmul($amountInTWD, (float)$rateToBase, 4);

                }
            }
        }

    } catch (PDOException $e) {
        error_log("獲取匯率資料庫錯誤: " . $e->getMessage());
    }

    return null; // 無法轉換
}
關鍵點：
bcmul() 函數： 這是 PHP 的 BC Math 擴展提供的函數，用於高精度浮點數運算。對於貨幣計算，務必使用 BC Math（或 GMP），避免標準浮點數的精度問題。在 php.ini 中確保 extension=bcmath 已啟用。

靈活的匯率來源： convertCurrency 可以接受一個 exchangeRate 參數。這讓你可以靈活地使用資料庫中的匯率，或者在特定情況下使用使用者手動輸入的匯率。

匯率方向： 匯率通常有兩個方向（例如 USD/TWD 和 TWD/USD）。你的 exchange_rates_table 需要儲存兩種方向的匯率，或者只儲存一種方向，但在查詢時根據需求進行倒數計算。我建議儲存 from_currency 和 to_currency，並確保每次只查詢一種方向的匯率。

透過主要幣別轉換： 如果直接找不到 fromCurrency 到 toCurrency 的匯率（例如，資料庫只有 USD->TWD 和 JPY->TWD），程式會嘗試先轉換到主要幣別（TWD），再從主要幣別轉換到目標幣別。

2. fetchAndStoreExchangeRates 方法
這個方法負責從第三方 API 獲取匯率並存儲到資料庫。這應該是一個獨立的 PHP 腳本，不應該每次網頁請求時都執行。

程式碼 (例如：scripts/update_exchange_rates.php)

PHP

<?php
// scripts/update_exchange_rates.php (這個文件應該獨立於 functions.php，但可以 include functions.php)

include_once('../functions.php'); // 根據你的文件結構調整路徑

// 假設你的資料庫配置已經在 functions.php 引入的 config.php 中
global $db_server, $db_name, $db_user, $db_passwd;
$pdo = null; // 初始化 PDO 物件

try {
    $pdo = openDB($db_server, $db_name, $db_user, $db_passwd);
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    // 設定你的第三方匯率 API 金鑰和基礎 URL
    $apiKey = '你的API金鑰'; // 從你的匯率服務商獲取，例如 Fixer.io, Open Exchange Rates
    $apiUrl = 'https://api.apilayer.com/fixer/latest'; // 以 Fixer.io 為例，請替換為你實際使用的 API
    $baseCurrencyForApi = 'TWD'; // API 返回的基準幣別，通常是 'USD' 或 'EUR'。這裡假設 API 以 TWD 為基準

    // 你需要獲取的目標幣別列表
    $targetCurrencies = ['USD', 'EUR', 'JPY', 'GBP', 'AUD', 'CAD', 'CNY', 'HKD', 'SGD', 'NZD']; // 根據需求增減

    $url = "$apiUrl?base=$baseCurrencyForApi&symbols=" . implode(',', $targetCurrencies);

    $ch = curl_init($url);
    curl_setopt($ch, CURLOPT_HTTPHEADER, ["apikey: $apiKey"]); // 設置 API 金鑰頭
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    $response = curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    curl_close($ch);

    if ($response === false) {
        throw new Exception('CURL 錯誤: ' . curl_error($ch));
    }

    $data = json_decode($response, true);

    if ($httpCode !== 200 || !isset($data['rates'])) {
        error_log("獲取匯率失敗。HTTP Code: $httpCode, API響應: " . print_r($data, true));
        throw new Exception('從 API 獲取匯率數據失敗。');
    }

    $rates = $data['rates'];
    $currentTimestamp = date('Y-m-d H:i:s');

    // 準備插入或更新資料庫的 SQL 語句
    // 如果是 INSERT ON DUPLICATE KEY UPDATE 或 REPLACE INTO，你的表需要有 unique key 在 from_currency 和 to_currency 上
    $insertSql = "INSERT INTO `exchange_rates_table` (`from_currency`, `to_currency`, `rate`, `updated_at`) 
                  VALUES (:from_currency, :to_currency, :rate, :updated_at)
                  ON DUPLICATE KEY UPDATE `rate` = VALUES(`rate`), `updated_at` = VALUES(`updated_at`)";
    $stmt = $pdo->prepare($insertSql);

    // 儲存從 baseCurrencyForApi 到其他幣別的匯率
    foreach ($rates as $currency => $rate) {
        if ((float)$rate > 0) {
            $stmt->bindValue(':from_currency', $baseCurrencyForApi);
            $stmt->bindValue(':to_currency', $currency);
            $stmt->bindValue(':rate', (string)$rate); // 儲存為字串以保持精度
            $stmt->bindValue(':updated_at', $currentTimestamp);
            $stmt->execute();
        }
    }

    // 儲存所有目標幣別到 baseCurrencyForApi 的反向匯率
    // 因為 1 A = X B，所以 1 B = 1/X A
    foreach ($rates as $currency => $rate) {
        if ((float)$rate > 0) {
            $inverseRate = bcdiv(1, (string)$rate, 6); // 計算反向匯率，保留6位小數
            $stmt->bindValue(':from_currency', $currency);
            $stmt->bindValue(':to_currency', $baseCurrencyForApi);
            $stmt->bindValue(':rate', (string)$inverseRate);
            $stmt->bindValue(':updated_at', $currentTimestamp);
            $stmt->execute();
        }
    }
    
    // 如果你的主要幣別 (TWD) 並非 API 的基準幣別 (例如 API 以 USD 為基準)，
    // 你需要額外處理 USD <-> TWD 的匯率，並以此為跳板轉換其他幣別。
    // 這個部分會根據你選用的 API 和主要幣別邏輯而有所不同，
    // 需要仔細設計你的 exchange_rates_table 和查詢邏輯。

    echo "匯率更新成功！\n";

} catch (Exception $e) {
    error_log("匯率更新失敗: " . $e->getMessage());
    echo "匯率更新失敗: " . $e->getMessage() . "\n";
} finally {
    $pdo = null;
}
?>
匯率資料庫表的建議結構 (exchange_rates_table)
SQL

CREATE TABLE `exchange_rates_table` (
    `id` INT AUTO_INCREMENT PRIMARY KEY,
    `from_currency` VARCHAR(3) NOT NULL,
    `to_currency` VARCHAR(3) NOT NULL,
    `rate` DECIMAL(18, 6) NOT NULL, -- 匯率通常需要高精度，根據你的需求調整小數位數
    `updated_at` DATETIME NOT NULL,
    UNIQUE KEY `idx_from_to_currency` (`from_currency`, `to_currency`) -- 確保每對幣別只有一條記錄
);
fetchAndStoreExchangeRates 的使用時機
這個方法不應該在每次用戶請求頁面時都執行，因為：

性能開銷大： 每次都呼叫第三方 API 會增加頁面載入時間。

API 頻率限制： 大多數免費或低價 API 都有嚴格的呼叫頻率限制。

最佳使用時機：

定時任務 (Cron Job)：
這是最推薦的方式。在伺服器上設定一個排程任務 (cron job)，每天固定時間 (例如每天凌晨 3 點) 自動執行 scripts/update_exchange_rates.php 這個腳本。這樣可以確保資料庫中的匯率保持更新，同時不會影響用戶體驗。

優點： 自動化、不干擾用戶、精準控制更新頻率。

缺點： 需要伺服器權限設定 cron job。

管理後台的手動觸發：
你可以在你的後台管理介面中，提供一個按鈕，讓管理員可以手動觸發 fetchAndStoreExchangeRates 函數來更新匯率。

優點： 靈活、適用於少量手動更新需求。

缺點： 依賴人工操作，可能不夠及時。

每次啟動應用程式時 (不推薦用於 Web 應用)：
這通常用於桌面應用或服務，在 Web 環境下，應用程式「啟動」的概念不明確。

我強烈建議你使用 定時任務 (Cron Job) 來定期更新匯率。

Cron Job 設定範例 (Linux 伺服器)
打開你的 cron 設定：

Bash

crontab -e
添加一行：

程式碼片段

0 3 * * * /usr/bin/php /volume1/web/MyMoze/scripts/update_exchange_rates.php >> /var/log/my_moze_exchange_rates.log 2>&1
0 3 * * *: 這表示每天凌晨 3 點執行。

第一個 0: 分鐘 (0-59)

第二個 3: 小時 (0-23)

第三個 *: 月份中的哪一天 (1-31)

第四個 *: 月份 (1-12)

第五個 *: 星期幾 (0-7，其中 0 和 7 都是星期日)

/usr/bin/php: 你的 PHP 解析器的路徑（請根據你的伺服器實際路徑調整）。

/volume1/web/MyMoze/scripts/update_exchange_rates.php: 你匯率更新腳本的絕對路徑。

>> /var/log/my_moze_exchange_rates.log 2>&1: 將腳本的輸出（包括錯誤）導向到日誌文件，方便查看更新結果。

有了這些方法，你的記帳程式就能夠處理多幣別記帳的需求了。記得在生產環境中保護好你的 API 金鑰！